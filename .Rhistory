colors <- c("green", "green", "green", "green", "green", "red", "red", "red", "red", "red", "blue", "blue", "blue", "blue", "blue")
# Principle Component Analysis
std_norm <- function(sample_data) {
norm_data <- c()
for(i in 1:dim(sample_data)[1]) {
row_mean <- mean(as.numeric(sample_data[i,]))
row_std <- sqrt(var(as.numeric(sample_data[i,])))
norm_row <- (as.numeric(sample_data[i,]) - row_mean) / row_std
norm_data <- rbind(norm_data, norm_row)
}
colnames(norm_data) <- colnames(sample_data)
return(norm_data)
}
pca_data <- std_norm(sample_data)
pca <- prcomp(t(pca_data))  # PCA using prcomp()
plot(pca$x[,1], pca$x[,2], pch = 1, col = colors, xlab = "PC1", ylab = "PC2", main = "Principal Component Analysis")  # plot of PC1 vs PC2
#legend("topright", c("Healthy", "Infected", "Treatment"), cex = .8, col = c("green", "red", "blue"), pch = 16)
text(pca$x[,1], pca$x[,2], labels = samples, col = colors)
# Scree plot
scree <- fviz_eig(pca)  # fviz_eig() and the code block below both calculate variance
# to generate a Scree plot
scree[1]
# Percentage of explained variances for PC1 and PC2 = 53.91 and 14.15
# variance = pca$sdev^2 / sum(pca$sdev^2)
# # variance[1] = 0.5391137
# # variance[2] = 0.1414559
#
# qplot(c(1:15), variance) +
#   geom_line() +
#   geom_point(size = 3) +
#   xlab("Principal Component") +
#   ylab("Variance Explained") +
#   ggtitle("Scree Plot") +
#   ylim(0, 1)
# Hierarchical Clustering
euc_dist <- dist(t(sample_data), method = "euclidean")
hier_cluster <- hclust(d = euc_dist, method = "single")
# Dendrogram Plot
plot(hier_cluster, main = "Dendrogram from Hierarchical Clustering", xlab = "Sample Data", ylab = "Distance", sub = " ")
# K-Means Clustering
k_mean <- kmeans(x = t(sample_data), center = 3)
fviz_cluster(k_mean, data = t(sample_data), main = "K-Means Clustering", palette = "Set2")
fviz_nbclust(x = t(sample_data), centers = 2, FUNcluster = kmeans, method = "silhouette")
# TSNE
library(Rtsne)
tsne <- Rtsne(X = t(sample_data), perplexity = 2)
plot(tsne$Y, col = colors, bg = colors, pch = 21, cex = 2, main = "TSNE")
plot(tsne$Y, col = "white", pch = 21, cex = 2, main = "TSNE")
text(tsne$Y, labels = samples, col = colors)
scree <- fviz_eig(pca)
scree
# assignment 4
library(rio)
library(ggplot2)
library(factoextra)
infection_data <- import(file = "/Users/Trang/Downloads/GE_Infection.xlsx")
sample_data <- infection_data[, -1]  #remove first column with gene names
# gene_names <- infection_data[, 1]  # create a vector containing gene names
# rownames(sample_data) <- gene_names  # name each row
samples <- c("Healthy", "Healthy", "Healthy", "Healthy", "Healthy", "Infected", "Infected", "Infected", "Infected", "Infected", "Treatment", "Treatment", "Treatment", "Treatment", "Treatment")
colors <- c("green", "green", "green", "green", "green", "red", "red", "red", "red", "red", "blue", "blue", "blue", "blue", "blue")
# Principle Component Analysis
std_norm <- function(sample_data) {
norm_data <- c()
for(i in 1:dim(sample_data)[1]) {
row_mean <- mean(as.numeric(sample_data[i,]))
row_std <- sqrt(var(as.numeric(sample_data[i,])))
norm_row <- (as.numeric(sample_data[i,]) - row_mean) / row_std
norm_data <- rbind(norm_data, norm_row)
}
colnames(norm_data) <- colnames(sample_data)
return(norm_data)
}
pca_data <- std_norm(sample_data)
pca <- prcomp(t(pca_data))  # PCA using prcomp()
plot(pca$x[,1], pca$x[,2], pch = 1, col = colors, xlab = "PC1", ylab = "PC2", main = "Principal Component Analysis")  # plot of PC1 vs PC2
#legend("topright", c("Healthy", "Infected", "Treatment"), cex = .8, col = c("green", "red", "blue"), pch = 16)
text(pca$x[,1], pca$x[,2], labels = samples, col = colors)
# Scree plot
scree <- fviz_eig(pca)  # fviz_eig() and the code block below both calculate variance
# to generate a Scree plot
scree
scree[1]
# Percentage of explained variances for PC1 and PC2 = 53.91 and 14.15
# variance = pca$sdev^2 / sum(pca$sdev^2)
# # variance[1] = 0.5391137
# # variance[2] = 0.1414559
#
# qplot(c(1:15), variance) +
#   geom_line() +
#   geom_point(size = 3) +
#   xlab("Principal Component") +
#   ylab("Variance Explained") +
#   ggtitle("Scree Plot") +
#   ylim(0, 1)
# Hierarchical Clustering
euc_dist <- dist(t(sample_data), method = "euclidean")
hier_cluster <- hclust(d = euc_dist, method = "single")
# Dendrogram Plot
plot(hier_cluster, main = "Dendrogram from Hierarchical Clustering", xlab = "Sample Data", ylab = "Distance", sub = " ")
# K-Means Clustering
k_mean <- kmeans(x = t(sample_data), center = 3)
fviz_cluster(k_mean, data = t(sample_data), main = "K-Means Clustering", palette = "Set2")
fviz_nbclust(x = t(sample_data), centers = 2, FUNcluster = kmeans, method = "silhouette")
# TSNE
library(Rtsne)
tsne <- Rtsne(X = t(sample_data), perplexity = 2)
plot(tsne$Y, col = colors, bg = colors, pch = 21, cex = 2, main = "TSNE")
plot(tsne$Y, col = "white", pch = 21, cex = 2, main = "TSNE")
text(tsne$Y, labels = samples, col = colors)
# assignment 4
library(rio)
library(ggplot2)
library(factoextra)
infection_data <- import(file = "/Users/Trang/Downloads/GE_Infection.xlsx")
sample_data <- infection_data[, -1]  #remove first column with gene names
# gene_names <- infection_data[, 1]  # create a vector containing gene names
# rownames(sample_data) <- gene_names  # name each row
samples <- c("Healthy", "Healthy", "Healthy", "Healthy", "Healthy", "Infected", "Infected", "Infected", "Infected", "Infected", "Treatment", "Treatment", "Treatment", "Treatment", "Treatment")
colors <- c("green", "green", "green", "green", "green", "red", "red", "red", "red", "red", "blue", "blue", "blue", "blue", "blue")
# Principle Component Analysis
std_norm <- function(sample_data) {
norm_data <- c()
for(i in 1:dim(sample_data)[1]) {
row_mean <- mean(as.numeric(sample_data[i,]))
row_std <- sqrt(var(as.numeric(sample_data[i,])))
norm_row <- (as.numeric(sample_data[i,]) - row_mean) / row_std
norm_data <- rbind(norm_data, norm_row)
}
colnames(norm_data) <- colnames(sample_data)
return(norm_data)
}
pca_data <- std_norm(sample_data)
pca <- prcomp(t(pca_data))  # PCA using prcomp()
plot(pca$x[,1], pca$x[,2], pch = 1, col = colors, xlab = "PC1", ylab = "PC2", main = "Principal Component Analysis")  # plot of PC1 vs PC2
#legend("topright", c("Healthy", "Infected", "Treatment"), cex = .8, col = c("green", "red", "blue"), pch = 16)
text(pca$x[,1], pca$x[,2], labels = samples, col = colors)
# Scree plot
scree <- fviz_eig(pca)  # fviz_eig() and the code block below both calculate variance
# to generate a Scree plot
scree
scree[1]
# Percentage of explained variances for PC1 and PC2 = 53.91 and 14.15
# variance = pca$sdev^2 / sum(pca$sdev^2)
# # variance[1] = 0.5391137
# # variance[2] = 0.1414559
#
# qplot(c(1:15), variance) +
#   geom_line() +
#   geom_point(size = 3) +
#   xlab("Principal Component") +
#   ylab("Variance Explained") +
#   ggtitle("Scree Plot") +
#   ylim(0, 1)
# Hierarchical Clustering
euc_dist <- dist(t(sample_data), method = "euclidean")
hier_cluster <- hclust(d = euc_dist, method = "single")
# Dendrogram Plot
plot(hier_cluster, main = "Dendrogram from Hierarchical Clustering", xlab = "Sample Data", ylab = "Distance", sub = " ")
# K-Means Clustering
k_mean <- kmeans(x = t(sample_data), center = 3)
fviz_cluster(k_mean, data = t(sample_data), main = "K-Means Clustering", palette = "Set2")
fviz_nbclust(x = t(sample_data), centers = 2, FUNcluster = kmeans, method = "silhouette")
# TSNE
library(Rtsne)
tsne <- Rtsne(X = t(sample_data), perplexity = 2)
plot(tsne$Y, col = colors, bg = colors, pch = 21, cex = 2, main = "t-SNE")
plot(tsne$Y, col = "white", pch = 21, cex = 2, main = "t-SNE")
text(tsne$Y, labels = samples, col = colors)
scree <- fviz_eig(pca)  # fviz_eig() and the code block below both calculate variance
# to generate a Scree plot
scree
scree[1]
k_mean <- kmeans(x = t(sample_data), center = 2)
fviz_cluster(k_mean, data = t(sample_data), main = "K-Means Clustering", palette = "Set2")
fviz_nbclust(x = t(sample_data), centers = 2, FUNcluster = kmeans, method = "silhouette")
> install.packages("swirl")
install.packages("swirl")
library("swirl")
swirl()
system.time(install.packages("Hmisc"))
system.time(install.packages("Hmisc"))
system.time(install.packages("lme4"))
system.time(install.packages("MASS"))
system.time(install.packages("dslabs"))
install.packages(devtools)
install.packages("devtools")
install.packages("devtools")
library(devtools)
install_github("jokergoo/ComplexHeatmap")
system.time(install_github("jokergoo/ComplexHeatmap"))
.libPaths()
installed.packages()[, "LibPath"]
num_1 <- c(1, 2, 3, 4)
num_2 <- c(5, 6, 7, 8)
num_1
num_2
char_1 <- c("a", "b", "c", "d")
char_2 <- c("e", "f", "g", "h")
length(char_1)
mean(num_1)
logic_1 <- c(TRUE, FALSE, TRUE, FALSE)
logic_2 <- c(TRUE, TRUE, FALSE, FALSE)
logic_1[3] == logic_2[3]
cor(num_1)
cor()
cor(num_1,num_2)
mean(logic_1)
cor(num_1, num_2)
install.packages("tidyverse")
install.packages("tidyverse")
install.packages("tidyverse")
install.packages("tidyverse")
library(readr)
cards <- read_csv("~/Downloads/cards.csv")
View(cards)
source("~/.active-rstudio-document")
source("~/.active-rstudio-document")
most_pure <- max(drinks[ , 5])
avg_beer <- mean(drinks[ , 2])
avg_beer <- mean(drinks$beer_servings)
avg_beer <- mean(drinks$beer_servings)
avg_beer
max_pure <- max(drinks$total_litres_of_pure_alcohol)
max_pure
row_max <- which.max(max_pure)
row_max
row_max <- which.max(drinks$total_litres_of_pure_alcohol)
row_max
max_pure <- max(drinks$total_litres_of_pure_alcohol)
max_pure
row_num <- which.max(drinks$total_litres_of_pure_alcohol)
row_num
country_name <- drinks$country[row_num]
country_name
max_pure <- max(drinks$total_litres_of_pure_alcohol)
max_pure
row_num <- which.max(drinks$total_litres_of_pure_alcohol)
row_num
country_name <- drinks$country[row_num]
country_name
min_pure <- min(drinks$total_litres_of_pure_alcohol)
min_pure
row_num <- which.min(drinks$total_litres_of_pure_alcohol)
row_num
country_name <- drinks$country[row_num]
country_name
drinks['number_of_types_of_alcohol'] <- apply(drinks, 1, function(row) length(row[row != 0]))
drinks['number_of_types_of_alcohol'] <- apply(drinks, 1, function(row) length(row[row != 0]))
drinks_filtered <- drinks[drinks['number_of_types_of_alcohol'] == 1]
filter_vector <- apply(drinks[, 1:3], 1, function(x) all(x == 0))
filtered_drinks <- drinks[filter_vector, ]
filtered_drinks
filter_vector <- apply(drinks[, 1:3], 1, function(x) all(x == 0))
filtered_drinks <- drinks[filter_vector, ]
print(filtered_drinks)
View(filtered_drinks)
filter_vector <- apply(drinks[, 2:4], 1, function(x) all(x == 0))
filtered_drinks <- drinks[filter_vector, ]
print(filtered_drinks)
View(filtered_drinks)
filter_vector <- apply(drinks[, 2], 1, function(x) all(x == 0))
filtered_drinks <- drinks[filter_vector, ]
print(filtered_drinks)
filter_vector <- apply(drinks[, 4], 1, function(x) all(x == 0))
filtered_drinks <- drinks[filter_vector, ]
print(filtered_drinks)
filter_vector <- apply(drinks[, 3], 1, function(x) all(x == 0))
filtered_drinks <- drinks[filter_vector, ]
print(filtered_drinks)
filter_vector <- apply(drinks[, 4], 1, function(x) all(x == 0))
filtered_drinks <- drinks[filter_vector, ]
print(filtered_drinks)
filter <- apply(drinks[, 4], 1, function(x) all(x == 0))
flt_drinks <- drinks[filter, ]
print(flt_drinks)
View(flt_drinks)
filter <- apply(drinks[, 4], 1, function(x) all(x == 0))
flt_drinks <- drinks[filter, ]
flt_drinks
# Statistical functions
```{r}
knitr::opts_chunk$set(echo = TRUE)
data(warpbreaks)
model <- lm(breaks ~ wool * tension, data = warpbreaks)
summary(model)
qqnorm(resid(model))
qqline(resid(model))
dev.copy(pdf, "qq_plot.pdf")
dev.off()
### Linked image
!(/Users/trang/Desktop/snoopy.jpg)
### Linked image
![Snoopy](/Users/Trang/Desktop/snoopy.jpg)
result <- chisq.test(department_A)
knitr::opts_chunk$set(echo = TRUE)
data(warpbreaks)
model <- lm(breaks ~ wool * tension, data = warpbreaks)
summary(model)
qqnorm(model$residuals)
qqline(model$residuals)
pdf("warpbreaks_qqplot.pdf")
qqnorm(model$residuals)
qqline(model$residuals)
dev.off()
data(UCBAdmissions)
department_A <- UCBAdmissions[,, "A"]
result <- chisq.test(department_A)
print(result)
knitr::opts_chunk$set(echo = TRUE)
result <- chisq.test(department_a)
knitr::opts_chunk$set(echo = TRUE)
data(warpbreaks)
model <- lm(breaks ~ wool * tension, data = warpbreaks)
summary(model)
qqnorm(resid(model))
qqline(resid(model))
dev.copy(pdf, "qq_plot.pdf")
dev.off()
data(UCBAdmissions)
department_a <- UCBAdmissions[,, "A"]
result <- chisq.test(department_a)
print(result)
par(mfrow = c(3, 2))
departments <- c("A", "B", "C", "D", "E", "F")
for (dept in departments) {
data <- UCBAdmissions[, , dept]
barplot(data, main = paste("Department", dept))
}
set.seed(123) # Set seed for reproducibility
sample_data <- rnorm(1000, mean = 5, sd = 2)
ecdf_plot <- ecdf(sample_data)
plot(ecdf_plot, main = "Empirical CDF")
abline(h = 0.8, col = "red")
q80 <- quantile(sample_data, 0.8)
print(q80)
# Create a new plot for adding points and curves
plot(1, type = "n", xlim = c(min(sample_data), max(sample_data)), ylim = c(0, 1),
xlab = "Data", ylab = "Cumulative Probability")
# Add the 80th percentile point
points(q80, 0.8, col = "blue", pch = 16)
# Add the curve
curve(ecdf_plot(x), col = "black", add = TRUE)
knitr::opts_chunk$set(echo = TRUE)
data(warpbreaks)
model <- lm(breaks ~ wool * tension, data = warpbreaks)
summary(model)
qqnorm(model$residuals)
qqline(model$residuals)
pdf("warpbreaks_qqplot.pdf")
qqnorm(model$residuals)
qqline(model$residuals)
dev.off()
data(UCBAdmissions)
department_a <- UCBAdmissions[,, "A"]
result <- chisq.test(department_a)
print(result)
```{r}
knitr::opts_chunk$set(echo = TRUE)
data(warpbreaks)
model <- lm(breaks ~ wool * tension, data = warpbreaks)
summary(model)
qqnorm(model$residuals)
qqline(model$residuals)
pdf("warpbreaks_qqplot.pdf")
qqnorm(model$residuals)
qqline(model$residuals)
dev.off()
data(UCBAdmissions)
department_a <- UCBAdmissions[,, "A"]
result <- chisq.test(department_a)
print(result)
par(mfrow = c(3, 2))
departments <- c("A", "B", "C", "D", "E", "F")
for (dept in departments) {
data <- UCBAdmissions[, , dept]
colors <- c("pink", "blue")
barplot(data, main = paste("Department", dept), col = colors)
}
knitr::opts_chunk$set(echo = TRUE)
data(warpbreaks)
model <- lm(breaks ~ wool * tension, data = warpbreaks)
summary(model)
qqnorm(model$residuals)
qqline(model$residuals)
pdf("warpbreaks_qqplot.pdf")
qqnorm(model$residuals)
qqline(model$residuals)
dev.off()
data(UCBAdmissions)
department_a <- UCBAdmissions[,, "A"]
result <- chisq.test(department_a)
print(result)
par(mfrow = c(3, 2))
departments <- c("A", "B", "C", "D", "E", "F")
for (dept in departments) {
data <- UCBAdmissions[, , dept]
colors <- c("white", "black")
barplot(data, main = paste("Department", dept), col = colors)
}
knitr::opts_chunk$set(echo = TRUE)
data(warpbreaks)
model <- lm(breaks ~ wool * tension, data = warpbreaks)
summary(model)
qqnorm(model$residuals)
qqline(model$residuals)
pdf("warpbreaks_qqplot.pdf")
qqnorm(model$residuals)
qqline(model$residuals)
dev.off()
data(UCBAdmissions)
department_a <- UCBAdmissions[,, "A"]
result <- chisq.test(department_a)
print(result)
par(mfrow = c(3, 2))
departments <- c("A", "B", "C", "D", "E", "F")
for (dept in departments) {
data <- UCBAdmissions[, , dept]
colors <- c("black", "white")
barplot(data, main = paste("Department", dept), col = colors)
}
knitr::opts_chunk$set(echo = TRUE)
data(warpbreaks)
model <- lm(breaks ~ wool * tension, data = warpbreaks)
summary(model)
qqnorm(model$residuals)
qqline(model$residuals)
pdf("warpbreaks_qqplot.pdf")
qqnorm(model$residuals)
qqline(model$residuals)
dev.off()
data(UCBAdmissions)
department_a <- UCBAdmissions[,, "A"]
result <- chisq.test(department_a)
print(result)
par(mfrow = c(3, 2))
departments <- c("A", "B", "C", "D", "E", "F")
for (dept in departments) {
data <- UCBAdmissions[, , dept]
colors <- c("blue", "white")
barplot(data, main = paste("Department", dept), col = colors)
}
knitr::opts_chunk$set(echo = TRUE)
data(warpbreaks)
model <- lm(breaks ~ wool * tension, data = warpbreaks)
summary(model)
qqnorm(model$residuals)
qqline(model$residuals)
pdf("warpbreaks_qqplot.pdf")
qqnorm(model$residuals)
qqline(model$residuals)
dev.off()
data(UCBAdmissions)
department_a <- UCBAdmissions[,, "A"]
result <- chisq.test(department_a)
print(result)
par(mfrow = c(3, 2))
departments <- c("A", "B", "C", "D", "E", "F")
for (dept in departments) {
data <- UCBAdmissions[, , dept]
colors <- c("blue", "white")
barplot(data, main = paste("Department", dept), col = colors)
}
set.seed(10) # set seed for reproducibility
sample_data <- rnorm(1000, mean = 5, sd = 2)
ecdf_plot <- ecdf(sample_data)
plot(ecdf_plot, main = "Empirical CDF")
abline(h = 0.8, col = "red")
q80 <- quantile(sample_data, 0.8)
print(q80)
# Create a new plot
plot(1, type = "n", xlim = c(min(sample_data), max(sample_data)), ylim = c(0, 1),
xlab = "Data", ylab = "Cumulative Probability")
# Add point that has x-coordinate equal to the q80 percentile
points(q80, 0.8, col = "blue", pch = 16)
knitr::opts_chunk$set(echo = TRUE)
data(warpbreaks)
model <- lm(breaks ~ wool * tension, data = warpbreaks)
summary(model)
qqnorm(model$residuals)
qqline(model$residuals)
pdf("warpbreaks_qqplot.pdf")
qqnorm(model$residuals)
qqline(model$residuals)
dev.off()
data(UCBAdmissions)
department_a <- UCBAdmissions[,, "A"]
result <- chisq.test(department_a)
print(result)
par(mfrow = c(3, 2))
departments <- c("A", "B", "C", "D", "E", "F")
for (dept in departments) {
data <- UCBAdmissions[, , dept]
colors <- c("blue", "white")
barplot(data, main = paste("Department", dept), col = colors)
}
set.seed(10) # set seed for reproducibility
sample_data <- rnorm(1000, mean = 5, sd = 2)
ecdf_plot <- ecdf(sample_data)
plot(ecdf_plot, main = "Empirical CDF")
abline(h = 0.8, col = "red")
q80 <- quantile(sample_data, 0.8)
print(q80)
# Create a new plot
plot(1, type = "n", xlim = c(min(sample_data), max(sample_data)), ylim = c(0, 1),
xlab = "Data", ylab = "Cumulative Probability")
# Add point that has x-coordinate equal to the q80 percentile
points(q80, 0.8, col = "blue", pch = 16)
# Add the curve
curve(ecdf_plot(x), col = "black", add = TRUE)
setwd("~/pytrim")
source("~/.active-rstudio-document")
